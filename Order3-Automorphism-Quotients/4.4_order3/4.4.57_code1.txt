sum := [[0,0] : i in [1..8]];
q := 1;

for j in [1..#sum] do
    p := NthPrime(j+1);
    Proj := ProjectiveSpace(GF(p^3),[1,1,1,1,4]);
    P<x,y,z,t>:=PolynomialRing(GF(p),4);
    A := 1;
    B := 1;
    C := 1;
    D := 3;
    E := 2;
    F := 2;
    f<x,y,z,t> := x*y*z*t*(A*(x^2+y^2+z^2+t^2)+B*(x*y+z*t)+C*(x+y)*(z+t))*(D*(x^2+y^2+z^2+t^2)+E*(x*y+z*t)+F*(x+y)*(z+t));

	
    Seq01 := {{[1,y1,z1,t1,w],[z1,1,y1,t1,w],[y1,z1,1,t1,w]}: y1,z1,t1,w in GF(p)|q*w^2 eq Evaluate(f,<1,y1,z1,t1>)};
    Seq01:=IndexedSet(Seq01);
    Seq11 := {};
    Seq11 := SetToIndexedSet(Seq11);
    for i in [1..#Seq01] do
        conversion:=SetToIndexedSet(Seq01[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq11,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq11,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq11,{p1,p2,p3});
        end if;
    end for; 

    Seq02 := {{[0,1,z1,t1,w],[z1,0,1,t1,w],[1,z1,0,t1,w]}: z1,t1,w in GF(p)|q*w^2 eq Evaluate(f,<0,1,z1,t1>)};
    Seq02:=IndexedSet(Seq02);
    Seq12 := {};
    Seq12 := SetToIndexedSet(Seq12);
    for i in [1..#Seq02] do
        conversion:=SetToIndexedSet(Seq02[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq12,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq12,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq12,{p1,p2,p3});
        end if;
    end for; 

    Seq03 := {{[0,0,1,t1,w],[1,0,0,t1,w],[0,1,0,t1,w]}: t1,w in GF(p)|q*w^2 eq Evaluate(f,<0,0,1,t1>)};
    Seq03:=IndexedSet(Seq03);
    Seq13 := {};
    Seq13 := SetToIndexedSet(Seq13);
    for i in [1..#Seq03] do
        conversion:=SetToIndexedSet(Seq03[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq13,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq13,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq13,{p1,p2,p3});
        end if;
    end for;  

    Seq04 := {{[0,0,0,1,w],[0,0,0,1,w],[0,0,0,1,w]}: w in GF(p)|q*w^2 eq Evaluate(f,<0,0,0,1>)};
    Seq04:=IndexedSet(Seq04);
    Seq14 := {};
    Seq14 := SetToIndexedSet(Seq14);
    for i in [1..#Seq04] do
        conversion:=SetToIndexedSet(Seq04[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq14,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq14,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq14,{p1,p2,p3});
        end if;
    end for;  


    Seq05 := {{[x1,x1^(p^2),x1^p,1,w],[x1^p,x1,x1^(p^2),1,w],[x1^(p^2),x1^p,x1,1,w]}: x1 in GF(p^3), w in GF(p) | (x1 notin GF(p)) and (q*w^2 eq Evaluate(f,<x1,x1^(p^2),x1^p,1>))};
    Seq05 :=IndexedSet(Seq05);
    Seq15 := {};
    Seq15 := SetToIndexedSet(Seq15);
    for i in [1..#Seq05] do
        conversion:=SetToIndexedSet(Seq05[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq15,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq15,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq15,{p1,p2,p3});
        end if;
    end for;

    Seq06 := {{[x1,x1^(p^2),x1^p,0,w],[x1^p,x1,x1^(p^2),0,w],[x1^(p^2),x1^p,x1,0,w]}: x1 in GF(p^3), w in GF(p) | (x1 notin GF(p)) and (q*w^2 eq Evaluate(f,<x1,x1^(p^2),x1^p,0>))};
    Seq06 :=IndexedSet(Seq06);
    Seq16 := {};
    Seq16 := SetToIndexedSet(Seq16);
    for i in [1..#Seq06] do
        conversion:=SetToIndexedSet(Seq06[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq16,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq16,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq16,{p1,p2,p3});
        end if;
    end for;

    Seq07 := {{[x1,x1^p,x1^(p^2),1,w],[x1^(p^2),x1,x1^p,1,w],[x1^p,x1^(p^2),x1,1,w]}: x1 in GF(p^3), w in GF(p) | (x1 notin GF(p)) and (q*w^2 eq Evaluate(f,<x1,x1^p,x1^(p^2),1>))};
    Seq07 :=IndexedSet(Seq07);
    Seq17 := {};
    Seq17 := SetToIndexedSet(Seq17);
    for i in [1..#Seq07] do
        conversion:=SetToIndexedSet(Seq07[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq17,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq17,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq17,{p1,p2,p3});
        end if;
    end for;

    Seq08 := {{[x1,x1^p,x1^(p^2),0,w],[x1^(p^2),x1,x1^p,0,w],[x1^p,x1^(p^2),x1,0,w]}: x1 in GF(p^3), w in GF(p) | (x1 notin GF(p)) and (q*w^2 eq Evaluate(f,<x1,x1^p,x1^(p^2),0>))};
    Seq08 :=IndexedSet(Seq08);
    Seq18 := {};
    Seq18 := SetToIndexedSet(Seq18);
    for i in [1..#Seq08] do
        conversion:=SetToIndexedSet(Seq08[i]);
        if #conversion eq 1 then
            bool1,p1 := conversion[1] in Proj;
            Include(~Seq18,{p1});
        elif #conversion eq 2 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            Include(~Seq18,{p1,p2});
        elif #conversion eq 3 then
            bool1,p1 := conversion[1] in Proj;
            bool2,p2 := conversion[2] in Proj;
            bool3,p3 := conversion[3] in Proj;
            Include(~Seq18,{p1,p2,p3});
        end if;
    end for;

    Seq21 := IndexedSetToSet(Seq11);
    Seq22 := IndexedSetToSet(Seq12);
    Seq23 := IndexedSetToSet(Seq13);
    Seq24 := IndexedSetToSet(Seq14);
    Seq25 := IndexedSetToSet(Seq15);
    Seq26 := IndexedSetToSet(Seq16);
    Seq27 := IndexedSetToSet(Seq17);
    Seq28 := IndexedSetToSet(Seq18);

    for x in Seq21 do
        if x in Seq22 then
            Exclude(~Seq21,x);
        elif x in Seq23 then
            Exclude(~Seq21,x);
        elif x in Seq24 then
            Exclude(~Seq21,x);
        elif x in Seq25 then
            Exclude(~Seq21,x);
        elif x in Seq26 then
            Exclude(~Seq21,x);
        elif x in Seq27 then
            Exclude(~Seq21,x);
        elif x in Seq28 then
            Exclude(~Seq21,x);
        end if;
    end for;
    for x in Seq22 do
        if x in Seq23 then
            Exclude(~Seq22,x);
        elif x in Seq24 then
            Exclude(~Seq22,x);
        elif x in Seq25 then
            Exclude(~Seq22,x);
        elif x in Seq26 then
            Exclude(~Seq22,x);
        elif x in Seq27 then
            Exclude(~Seq22,x);
        elif x in Seq28 then
            Exclude(~Seq22,x);
        end if;
    end for;
    for x in Seq23 do
        if x in Seq24 then
            Exclude(~Seq23,x);
        elif x in Seq25 then
            Exclude(~Seq23,x);
        elif x in Seq26 then
            Exclude(~Seq23,x);
        elif x in Seq27 then
            Exclude(~Seq23,x);
        elif x in Seq28 then
            Exclude(~Seq23,x);
        end if;
    end for;
    for x in Seq24 do
        if x in Seq25 then
            Exclude(~Seq24,x);
        elif x in Seq26 then
            Exclude(~Seq24,x);
        elif x in Seq27 then
            Exclude(~Seq24,x);
        elif x in Seq28 then
            Exclude(~Seq24,x);
        end if;
    end for;
    for x in Seq25 do
        if x in Seq26 then
            Exclude(~Seq25,x);
        elif x in Seq27 then
            Exclude(~Seq25,x);
        elif x in Seq28 then
            Exclude(~Seq25,x);
        end if;
    end for;
    for x in Seq26 do
        if x in Seq27 then
            Exclude(~Seq26,x);
        elif x in Seq28 then
            Exclude(~Seq26,x);
        end if;
    end for;
    for x in Seq27 do
        if x in Seq28 then
            Exclude(~Seq27,x);
        end if;
    end for;

    

    sum[j] :=  [#Seq21+#Seq22+#Seq23+#Seq24+#Seq25+#Seq26+#Seq27+#Seq28,p];
end for;

print "point counts", sum;

good_sum := sum;
print "good point counts", good_sum;

X:=[0 : i in [1..#good_sum]];
weight_4_level := [0,0,0];
weight_4_coeff := [[0,good_sum[i][2]] : i in [1..#good_sum]];
for C in [480] do
    M:=ModularForms(Gamma0(C),4);
    N:=NumberOfNewformClasses(M);
        if (N gt 0) then
                    for i in [1..N] do
                        L:=#Newforms(M)[i];
                            for k in [1..L] do
                                for j in [1..#good_sum] do
				    p := good_sum[j][2];
                                    if( IsCoercible(Integers(),Coefficient(Newform(M,i,k),p)) ) then 
                                        bool,x:=IsCoercible(Integers(),Coefficient(Newform(M,i,k),p));
                                            if (((1-x) mod p) eq (good_sum[j][1] mod p)) then
                                                weight_4_coeff[j] := [x,p];
                                                X[j] := 1;
                                            end if;
                                    end if;
                               end for;
                            if X eq [1 : i in [1..#good_sum]] then   
				ii := i; kk := k;
                                break;
                            else
                                weight_4_coeff := [[0,good_sum[i][2]] : i in [1..#good_sum]];
                                X := [0 : i in [1..#good_sum]];;
                            end if;
                        end for;
                    if X eq [1 : i in [1..#good_sum]] then
                       break;
                    end if;    
                  end for;
              if X eq [1 : i in [1..#good_sum]] then
                    weight_4_level := [C,ii,kk];
                    break;
              else
                    weight_4_coeff := [[0,good_sum[i][2]] : i in [1..#good_sum]];
                    X := [0 : i in [1..#good_sum]];
              end if;
        end if;
end for;

print "level", weight_4_level;



FirstCoefficient := function(counts,weight4level)

    nf := Newforms(CuspForms(weight4level[1],4))[weight4level[2],weight4level[3]];
    Z := Integers();
    s := [<Z!((x[1]+Coefficient(nf,x[2])-x[2]^3-1)/x[2]),x[2]> : x in counts];
    
    return(s);

end function;



SecondCoefficient := function(counts,weight4level,first_coeff)

    nf := Newforms(CuspForms(weight4level[1],4))[weight4level[2],weight4level[3]];
    Z := Integers();
    A := [<(x[1]+Coefficient(nf,x[2])-x[2]^3-first_coeff*(x[2]^2)-1)/x[2],x[2]> : x in counts | x[2] ne 3];
    X :=0;
    C := [0,0,0,0,0,0];
    for a,b,c,d,e,f in [-3..3] do
        X := [<a+b*LegendreSymbol(-1,x[2])+c*LegendreSymbol(2,x[2])+d*LegendreSymbol(-2,x[2])+e*LegendreSymbol(3,x[2])+f*LegendreSymbol(-3,x[2]),x[2]> : x in counts | x[2] ne 3];
        if X eq A then
            X := [<a+b*LegendreSymbol(-1,x[2])+c*LegendreSymbol(2,x[2])+d*LegendreSymbol(-2,x[2])+e*LegendreSymbol(3,x[2])+f*LegendreSymbol(-3,x[2]),x[2]> : x in counts | x[2] ne 3];
            C := [a,b,c,d,e,f];
            break;
        end if;
    end for;
    
    return(<C,A>);

end function;

if weight_4_level ne [0,0,0] then
	first_coeff := FirstCoefficient(good_sum,weight_4_level);
	print "First coefficient can be obtained from: ", first_coeff;
	second := SecondCoefficient(good_sum,weight_4_level,1);
	print "Second coefficient is ", second;
else
	print "not modular";
end if;
