Inputs: Q,R - Calabi-Yuas.
Outputs: Transf - vector consisting of matrices.
Function: TranslationIntersection - this function takes as input two Calabi-Yaus.
TranslationOfSimplex is used to find automorphisms of P that fixes this pair
of varieties (complete intersection).
The vector, Transf, consisting of the corresponding transformation is returned.
*/

TranslationIntersection := function(Q,R) 
    
    P<x,y,z,r,s,t> := ProjectiveSpace(Rationals(),5);
    Q := Evaluate(Q,<x,y,z,r,s,t>);
    R := Evaluate(R,<x,y,z,r,s,t>);
    bool0,point0 := [1,1,1,1,1,1] in P;
    bool1,point1 := [1,0,0,0,0,0] in P;
    bool2,point2 := [0,1,0,0,0,0] in P;
    bool3,point3 := [0,0,1,0,0,0] in P;
    bool4,point4 := [0,0,0,1,0,0] in P;
    bool5,point5 := [0,0,0,0,1,0] in P;
    bool6,point6 := [0,0,0,0,0,1] in P;
    All_points := [point0,point1,point2,point3,point4,point5,point6];

    List_of_automorphisms := [];

    for p1,p2,p3,p4,p5,p6,p7 in All_points do
        try
            p := [p1,p2,p3,p4,p5,p6,p7];
            T := TranslationOfSimplex(P,p);
            bool,T_inv := IsInvertible(T);
            if (Evaluate(Q,<x,y,z,r,s,t>) eq Evaluate(Q,<T(x),T(y),T(z),T(r),T(s),T(t)>)) and (Evaluate(R,<x,y,z,r,s,t>) eq Evaluate(R,<T(x),T(y),T(z),T(r),T(s),T(t)>)) and (T eq T_inv) then
                Include(~List_of_automorphisms,T);
            end if;
        catch e1; 
        end try;
    end for;

    Transf := AssociativeArray();
    for i in [1..#List_of_automorphisms] do
        T := Matrix(Rationals(),6,[0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0]);
        f<x,y,z,r,s,t> := List_of_automorphisms[i](x);
        T[1,1] := Evaluate(f,<1,0,0,0,0,0>);
        T[2,1] := Evaluate(f,<0,1,0,0,0,0>);
        T[3,1] := Evaluate(f,<0,0,1,0,0,0>);
        T[4,1] := Evaluate(f,<0,0,0,1,0,0>);
        T[5,1] := Evaluate(f,<0,0,0,0,1,0>);
        T[6,1] := Evaluate(f,<0,0,0,0,0,1>);
        f<x,y,z,r,s,t> := List_of_automorphisms[i](y);
        T[1,2] := Evaluate(f,<1,0,0,0,0,0>);
        T[2,2] := Evaluate(f,<0,1,0,0,0,0>);
        T[3,2] := Evaluate(f,<0,0,1,0,0,0>);
        T[4,2] := Evaluate(f,<0,0,0,1,0,0>);
        T[5,2] := Evaluate(f,<0,0,0,0,1,0>);
        T[6,2] := Evaluate(f,<0,0,0,0,0,1>);
        f<x,y,z,r,s,t> := List_of_automorphisms[i](z);
        T[1,3] := Evaluate(f,<1,0,0,0,0,0>);
        T[2,3] := Evaluate(f,<0,1,0,0,0,0>);
        T[3,3] := Evaluate(f,<0,0,1,0,0,0>);
        T[4,3] := Evaluate(f,<0,0,0,1,0,0>);
        T[5,3] := Evaluate(f,<0,0,0,0,1,0>);
        T[6,3] := Evaluate(f,<0,0,0,0,0,1>);
        f<x,y,z,r,s,t> := List_of_automorphisms[i](r);
        T[1,4] := Evaluate(f,<1,0,0,0,0,0>);
        T[2,4] := Evaluate(f,<0,1,0,0,0,0>);
        T[3,4] := Evaluate(f,<0,0,1,0,0,0>);
        T[4,4] := Evaluate(f,<0,0,0,1,0,0>);
        T[5,4] := Evaluate(f,<0,0,0,0,1,0>);
        T[6,4] := Evaluate(f,<0,0,0,0,0,1>);
        f<x,y,z,r,s,t> := List_of_automorphisms[i](s);
        T[1,5] := Evaluate(f,<1,0,0,0,0,0>);
        T[2,5] := Evaluate(f,<0,1,0,0,0,0>);
        T[3,5] := Evaluate(f,<0,0,1,0,0,0>);
        T[4,5] := Evaluate(f,<0,0,0,1,0,0>);
        T[5,5] := Evaluate(f,<0,0,0,0,1,0>);
        T[6,5] := Evaluate(f,<0,0,0,0,0,1>);
        f<x,y,z,r,s,t> := List_of_automorphisms[i](t);
        T[1,6] := Evaluate(f,<1,0,0,0,0,0>);
        T[2,6] := Evaluate(f,<0,1,0,0,0,0>);
        T[3,6] := Evaluate(f,<0,0,1,0,0,0>);
        T[4,6] := Evaluate(f,<0,0,0,1,0,0>);
        T[5,6] := Evaluate(f,<0,0,0,0,1,0>);
        T[6,6] := Evaluate(f,<0,0,0,0,0,1>);
    Transf[i] := T;
    end for;

    for i in [1..#Transf] do
        if Transf[i] eq Matrix(Rationals(),6,[1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,0,0,0, 0,0,0,1,0,0, 0,0,0,0,1,0, 0,0,0,0,0,1]) and i gt 1 then
            O := Transf[i];
            Transf[i] := Transf[1];
            Transf[1] := O;
        end if;
    end for;


    Transf := [Transf[i] : i in [1..#Transf]];
   
    return(Transf);

end function;

/*
Inputs: T - transformation matrix.
Outputs: [D,E] - vector consisting of diagonal matrix, D, and eigenvector 
matrix, E.
Function: Diagonalization - this function diagonalizes a transformation matrix, 
T, and returns a vector [D,E], where D is the corresponding diagonal matrix, 
and E is the corresponding matrix of eigenvectors.
*/

Diagonalization := function(T);

    D,E,rk := PrimaryRationalForm(T);

    return([D,E]);
end function;


/*
Inputs: T - transformation matrix.
        Q,R - equations of varieties in 6 variables.
Outputs: [f,h] - equations of the varieties in new coordinates.
Function: ChangeOfCoordinates - this function receives as input varieties
Q and R, and transformation matrix, T. It finds the diagonal matrix, D, and 
eigenvector matrix, E, corresponding to T, and creates a new set of variables,
v1,v2,v3,v4,v5,v6, on which D acts my multiplication by a scalar. The output is a 
pair of varieties, [f,h], which are the evaluations of Q and R at <v1,v2,v3,v4,v5,v6>.
*/

ChangeOfCoordinates := function(Q,R,T)

    D,E,rk := PrimaryRationalForm(T);
      
    P<x,y,z,r,s,t> := PolynomialRing(Rationals(),6);
    bool003,inv := IsInvertible(E);
    tr_inv := Transpose(inv);

    v1 := tr_inv[1,1]*x+tr_inv[2,1]*y+tr_inv[3,1]*z+tr_inv[4,1]*r+tr_inv[5,1]*s+tr_inv[6,1]*t;
    v2 := tr_inv[1,2]*x+tr_inv[2,2]*y+tr_inv[3,2]*z+tr_inv[4,2]*r+tr_inv[5,2]*s+tr_inv[6,2]*t;
    v3 := tr_inv[1,3]*x+tr_inv[2,3]*y+tr_inv[3,3]*z+tr_inv[4,3]*r+tr_inv[5,3]*s+tr_inv[6,3]*t;
    v4 := tr_inv[1,4]*x+tr_inv[2,4]*y+tr_inv[3,4]*z+tr_inv[4,4]*r+tr_inv[5,4]*s+tr_inv[6,4]*t;
    v5 := tr_inv[1,5]*x+tr_inv[2,5]*y+tr_inv[3,5]*z+tr_inv[4,5]*r+tr_inv[5,5]*s+tr_inv[6,5]*t;
    v6 := tr_inv[1,6]*x+tr_inv[2,6]*y+tr_inv[3,6]*z+tr_inv[4,6]*r+tr_inv[5,6]*s+tr_inv[6,6]*t;


    f<x,y,z,r,s,t> := Evaluate(Q,<v1,v2,v3,v4,v5,v6>);
    h<x,y,z,r,s,t> := Evaluate(R,<v1,v2,v3,v4,v5,v6>);
    return([f,h]);

end function;



/*
Inputs: f,h - equations of varieties.
        D - diagonal matrix of order 2 whose eigenvectors are the variables 
        that define f.
        min_prime_index - prime number.
        max_prime index - prime number.
Outputs: sum - vector of pairs [s,p], where s is the number of points in 
ProjectiveSpace(GF(p^2),[1,1,1,1,1,1]) of quotient of the complete intersection of f and h 
by the automorphism D, where p is a prime between min_prime_index and max_prime_index.
Function: CountPoints - this function counts the number of points in 
ProjectiveSpace(GF(p^2),[1,1,1,1,1,1]) on the quotient of the complete intersection of f and h
by the automorphism D, where p is a prime between min_prime_index and max_prime_index.
*/


CountPoints := function(f,h,D,min_prime_index,max_prime_index)

h1 := f;
h2 := h;
sum := [[0,NthPrime(i+1)] : i in [1..(max_prime_index-min_prime_index+1)]];

for j in [min_prime_index..max_prime_index] do
 
    p := NthPrime(j+1);
    k:=GF(p^2);
    g := Generator(k);
    Proj := ProjectiveSpace(GF(p^2),[1,1,1,1,1,1]);
    P<x,y,z,r,s,t>:=PolynomialRing(GF(p),6);


    tr,f := IsCoercible(P,h1);
    tr,h := IsCoercible(P,h2);


    
    if D eq Matrix(Rationals(),6,[1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,0,0,0, 0,0,0,1,0,0, 0,0,0,0,1,0, 0,0,0,0,0,1]) then
        Seq01 := {[1,y1,z1,r1,s1,t1] : y1,z1,r1,s1,t1 in GF(p)|(Evaluate(f,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,t1>) eq 0)};
        Seq01:=IndexedSet(Seq01);
        Seq11 := {};
        Seq11 := SetToIndexedSet(Seq11);
        for i in [1..#Seq01] do
            bool1,p1 := Seq01[i] in Proj;
            Include(~Seq11,{p1});
        end for; 

        Seq02 := {[0,1,z1,r1,s1,t1] : z1,r1,s1,t1 in GF(p)|(Evaluate(f,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,t1>) eq 0)};
        Seq02:=IndexedSet(Seq02);
        Seq12 := {};
        Seq12 := SetToIndexedSet(Seq12);
        for i in [1..#Seq02] do
            bool1,p1 := Seq02[i] in Proj;
            Include(~Seq12,{p1});
        end for; 

        Seq03 := {[0,0,1,r1,s1,t1] : r1,s1,t1 in GF(p)|(Evaluate(f,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,0,1,r1,s1,t1>) eq 0)};
        Seq03:=IndexedSet(Seq03);
        Seq13 := {};
        Seq13 := SetToIndexedSet(Seq13);
        for i in [1..#Seq03] do
            bool1,p1 := Seq03[i] in Proj;
            Include(~Seq13,{p1});
        end for; 
    
        Seq04 := {[0,0,0,1,s1,t1] : s1,t1 in GF(p)|(Evaluate(f,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(h,<0,0,0,1,s1,t1>) eq 0)};
        Seq04:=IndexedSet(Seq04);
        Seq14 := {};
        Seq14 := SetToIndexedSet(Seq14);
        for i in [1..#Seq04] do
            bool1,p1 := Seq04[i] in Proj;
            Include(~Seq14,{p1});
        end for; 

        Seq05 := {[0,0,0,0,1,t1] : t1 in GF(p)|(Evaluate(f,<0,0,0,0,1,t1>) eq 0) and (Evaluate(h,<0,0,0,0,1,t1>) eq 0)};
        Seq05:=IndexedSet(Seq05);
        Seq15 := {};
        Seq15 := SetToIndexedSet(Seq15);
        for i in [1..#Seq05] do
            bool1,p1 := Seq05[i] in Proj;
            Include(~Seq15,{p1});
        end for;

        Seq16 := {};
        if (Evaluate(f,<0,0,0,0,0,1>) eq 0) and (Evaluate(h,<0,0,0,0,0,1>) eq 0) then
            b1,p1 := [0,0,0,0,0,1] in Proj;
            Seq16 := {p1};
        end if;


        sum[j] := [#Seq11+#Seq12+#Seq13+#Seq14+#Seq15+#Seq16,p];

    elif D eq Matrix(Rationals(),6,[1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,0,0,0, 0,0,0,1,0,0, 0,0,0,0,1,0, 0,0,0,0,0,-1]) then
        
        Seq01 := {{[1,y1,z1,r1,s1,t1],[1,y1,z1,r1,s1,-t1]}: y1,z1,r1,s1,t1 in GF(p)|(Evaluate(f,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<1,y1,z1,r1,s1,-t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,-t1>) eq 0)};
        Seq01:=IndexedSet(Seq01);
        Seq11 := {};
        Seq11 := SetToIndexedSet(Seq11);
        for i in [1..#Seq01] do
            conversion:=SetToIndexedSet(Seq01[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq11,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq11,{p1,p2});
            end if;
        end for; 

        Seq02 := {{[0,1,z1,r1,s1,t1],[0,1,z1,r1,s1,-t1]}: z1,r1,s1,t1 in GF(p)|(Evaluate(f,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,1,z1,r1,s1,-t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,-t1>) eq 0)};
        Seq02:=IndexedSet(Seq02);
        Seq12 := {};
        Seq12 := SetToIndexedSet(Seq12);
        for i in [1..#Seq02] do
            conversion:=SetToIndexedSet(Seq02[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq12,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq12,{p1,p2});
            end if;
        end for; 

        Seq03 := {{[0,0,1,r1,s1,t1],[0,0,1,r1,s1,-t1]}: r1,s1,t1 in GF(p)|(Evaluate(f,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,0,1,r1,s1,-t1>) eq 0) and (Evaluate(h,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,0,1,r1,s1,-t1>) eq 0)};
        Seq03:=IndexedSet(Seq03);
        Seq13 := {};
        Seq13 := SetToIndexedSet(Seq13);
        for i in [1..#Seq03] do
            conversion:=SetToIndexedSet(Seq03[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq13,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq13,{p1,p2});
            end if;
        end for; 

        Seq04 := {{[0,0,0,1,s1,t1],[0,0,0,1,s1,-t1]}: s1,t1 in GF(p)|(Evaluate(f,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(f,<0,0,0,1,s1,-t1>) eq 0) and (Evaluate(h,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(h,<0,0,0,1,s1,-t1>) eq 0)};
        Seq04:=IndexedSet(Seq04);
        Seq14 := {};
        Seq14 := SetToIndexedSet(Seq14);
        for i in [1..#Seq04] do
            conversion:=SetToIndexedSet(Seq04[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq14,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq14,{p1,p2});
            end if;
        end for; 

        Seq05 := {{[0,0,0,0,1,t1],[0,0,0,0,1,-t1]}: t1 in GF(p)|(Evaluate(f,<0,0,0,0,1,t1>) eq 0) and (Evaluate(f,<0,0,0,0,1,-t1>) eq 0) and (Evaluate(h,<0,0,0,0,1,t1>) eq 0) and (Evaluate(h,<0,0,0,0,1,-t1>) eq 0)};
        Seq05:=IndexedSet(Seq05);
        Seq15 := {};
        Seq15 := SetToIndexedSet(Seq15);
        for i in [1..#Seq05] do
            conversion:=SetToIndexedSet(Seq05[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq15,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq15,{p1,p2});
            end if;
        end for; 

        if (Evaluate(f,<0,0,0,0,0,1>) eq 0) and (Evaluate(f,<0,0,0,0,0,-1>) eq 0) and (Evaluate(h,<0,0,0,0,0,1>) eq 0) and (Evaluate(h,<0,0,0,0,0,-1>) eq 0) then
            Seq06 := {[0,0,0,0,0,1]};
            Seq06 := SetToIndexedSet(Seq06);
            Seq16 := {};
            Seq16 := SetToIndexedSet(Seq16);
            bool1,p1 := Seq06[1] in Proj;
            Include(~Seq16,{p1});
        else
            Seq16 := SetToIndexedSet({});
        end if;
    
        SquareRoots := {SquareRoot(w1) : w1 in GF(p^2)|w1 ne 0 and w1 in GF(p) and IsSquare(w1) eq true and SquareRoot(w1) notin GF(p)};
        sqrt := Representative(SquareRoots);
        times_SquareRoots := {a*sqrt : a in GF(p)};

        Seq07 := {{[x1,y1,z1,r1,s1,1],[-x1,-y1,-z1,-r1,-s1,1]}: x1,y1,z1,r1,s1 in times_SquareRoots|(x1 notin GF(p) or y1 notin GF(p) or z1 notin GF(p) or r1 notin GF(p) or s1 notin GF(p)) and (Evaluate(f,<x1,y1,z1,r1,s1,1>) eq 0) and (Evaluate(f,<x1,y1,z1,r1,s1,-1>) eq 0) and (Evaluate(h,<x1,y1,z1,r1,s1,1>) eq 0) and (Evaluate(h,<x1,y1,z1,r1,s1,-1>) eq 0)};
        Seq07:=IndexedSet(Seq07);
        Seq17 := {};
        Seq17 := SetToIndexedSet(Seq17);
        for i in [1..#Seq07] do
            conversion:=SetToIndexedSet(Seq07[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq17,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq17,{p1,p2});
            end if;
        end for; 



        Seq21 := IndexedSetToSet(Seq11);
        Seq22 := IndexedSetToSet(Seq12);
        Seq23 := IndexedSetToSet(Seq13);
        Seq24 := IndexedSetToSet(Seq14);
        Seq25 := IndexedSetToSet(Seq15);
        Seq26 := IndexedSetToSet(Seq16);
        Seq27 := IndexedSetToSet(Seq17);


        /*Check for repeated points*/
        for x in Seq27 do
            if x in Seq21 then
                Exclude(~Seq27,x);
            elif x in Seq22 then
                Exclude(~Seq27,x);
            elif x in Seq23 then
                Exclude(~Seq27,x);
            elif x in Seq24 then
                Exclude(~Seq27,x);
            elif x in Seq25 then
                Exclude(~Seq27,x);
            elif x in Seq26 then
                Exclude(~Seq27,x);
            end if;
        end for;

        sum[j] :=  [#Seq21+#Seq22+#Seq23+#Seq24+#Seq25+#Seq26+#Seq27,p];

    elif D eq Matrix(Rationals(),6,[1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,0,0,0, 0,0,0,1,0,0, 0,0,0,0,-1,0, 0,0,0,0,0,-1]) then
        
        Seq01 := {{[1,y1,z1,r1,s1,t1],[1,y1,z1,r1,-s1,-t1]}: y1,z1,r1,s1,t1 in GF(p)|(Evaluate(f,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<1,y1,z1,r1,-s1,-t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,-s1,-t1>) eq 0)};
        Seq01:=IndexedSet(Seq01);
        Seq11 := {};
        Seq11 := SetToIndexedSet(Seq11);
        for i in [1..#Seq01] do
            conversion:=SetToIndexedSet(Seq01[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq11,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq11,{p1,p2});
            end if;
        end for; 

        Seq02 := {{[0,1,z1,r1,s1,t1],[0,1,z1,r1,-s1,-t1]}: z1,r1,s1,t1 in GF(p)|(Evaluate(f,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,1,z1,r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,-s1,-t1>) eq 0)};
        Seq02:=IndexedSet(Seq02);
        Seq12 := {};
        Seq12 := SetToIndexedSet(Seq12);
        for i in [1..#Seq02] do
            conversion:=SetToIndexedSet(Seq02[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq12,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq12,{p1,p2});
            end if;
        end for; 

        Seq03 := {{[0,0,1,r1,s1,t1],[0,0,1,r1,-s1,-t1]}: r1,s1,t1 in GF(p)|(Evaluate(f,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,0,1,r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,0,1,r1,-s1,-t1>) eq 0)};
        Seq03:=IndexedSet(Seq03);
        Seq13 := {};
        Seq13 := SetToIndexedSet(Seq13);
        for i in [1..#Seq03] do
            conversion:=SetToIndexedSet(Seq03[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq13,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq13,{p1,p2});
            end if;
        end for; 

        Seq04 := {{[0,0,0,1,s1,t1],[0,0,0,1,-s1,-t1]}: s1,t1 in GF(p)|(Evaluate(f,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(f,<0,0,0,1,-s1,-t1>) eq 0) and (Evaluate(h,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(h,<0,0,0,1,-s1,-t1>) eq 0)};
        Seq04:=IndexedSet(Seq04);
        Seq14 := {};
        Seq14 := SetToIndexedSet(Seq14);
        for i in [1..#Seq04] do
            conversion:=SetToIndexedSet(Seq04[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq14,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq14,{p1,p2});
            end if;
        end for; 

        Seq05 := {{[0,0,0,0,1,t1],[0,0,0,0,-1,-t1]}: t1 in GF(p)|(Evaluate(f,<0,0,0,0,1,t1>) eq 0) and (Evaluate(f,<0,0,0,0,-1,-t1>) eq 0) and (Evaluate(h,<0,0,0,0,1,t1>) eq 0) and (Evaluate(h,<0,0,0,0,-1,-t1>) eq 0)};
        Seq05:=IndexedSet(Seq05);
        Seq15 := {};
        Seq15 := SetToIndexedSet(Seq15);
        for i in [1..#Seq05] do
            conversion:=SetToIndexedSet(Seq05[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq15,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq15,{p1,p2});
            end if;
        end for; 

        if (Evaluate(f,<0,0,0,0,0,1>) eq 0) and (Evaluate(f,<0,0,0,0,0,-1>) eq 0) and (Evaluate(h,<0,0,0,0,0,1>) eq 0) and (Evaluate(h,<0,0,0,0,0,-1>) eq 0) then
            Seq06 := {[0,0,0,0,0,1]};
            Seq06 := SetToIndexedSet(Seq06);
            Seq16 := {};
            Seq16 := SetToIndexedSet(Seq16);
            bool1,p1 := Seq06[1] in Proj;
            Include(~Seq16,{p1});
        else
            Seq16 := SetToIndexedSet({});
        end if;

        SquareRoots := {SquareRoot(w1) : w1 in GF(p^2)|w1 ne 0 and w1 in GF(p) and IsSquare(w1) eq true and SquareRoot(w1) notin GF(p)};
        sqrt := Representative(SquareRoots);
        times_SquareRoots := {a*sqrt : a in GF(p)};

        Seq07 := {{[x1,y1,z1,r1,1,t1],[-x1,-y1,-z1,-r1,1,t1]}: x1,y1,z1,r1 in times_SquareRoots, t1 in GF(p)|(x1 notin GF(p) or y1 notin GF(p) or z1 notin GF(p) or r1 notin GF(p)) and (Evaluate(f,<x1,y1,z1,r1,1,t1>) eq 0) and (Evaluate(f,<-x1,-y1,-z1,-r1,1,t1>) eq 0) and (Evaluate(h,<x1,y1,z1,r1,1,t1>) eq 0) and (Evaluate(h,<-x1,-y1,-z1,-r1,1,t1>) eq 0)};
        Seq07:=IndexedSet(Seq07);
        Seq17 := {};
        Seq17 := SetToIndexedSet(Seq17);
        for i in [1..#Seq07] do
            conversion:=SetToIndexedSet(Seq07[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq17,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq17,{p1,p2});
            end if;
        end for; 

        Seq08 := {{[x1,y1,z1,r1,0,1],[-x1,-y1,-z1,-r1,0,1]}: x1,y1,z1,r1 in times_SquareRoots| (x1 notin GF(p) or y1 notin GF(p) or z1 notin GF(p) or r1 notin GF(p)) and (Evaluate(f,<x1,y1,z1,r1,0,1>) eq 0) and (Evaluate(f,<-x1,-y1,-z1,-r1,0,1>) eq 0) and (Evaluate(h,<x1,y1,z1,r1,0,1>) eq 0) and (Evaluate(h,<-x1,-y1,-z1,-r1,0,1>) eq 0)};
        Seq08:=IndexedSet(Seq08);
        Seq18 := {};
        Seq18 := SetToIndexedSet(Seq18);
        for i in [1..#Seq08] do
            conversion:=SetToIndexedSet(Seq08[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq18,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq18,{p1,p2});
            end if;
        end for; 

        Seq21 := IndexedSetToSet(Seq11);
        Seq22 := IndexedSetToSet(Seq12);
        Seq23 := IndexedSetToSet(Seq13);
        Seq24 := IndexedSetToSet(Seq14);
        Seq25 := IndexedSetToSet(Seq15);
        Seq26 := IndexedSetToSet(Seq16);
        Seq27 := IndexedSetToSet(Seq17);
        Seq28 := IndexedSetToSet(Seq18);



        /*Check for repeated points*/
        for x in Seq27 do
            if x in Seq21 then
                Exclude(~Seq27,x);
            elif x in Seq22 then
                Exclude(~Seq27,x);
            elif x in Seq23 then
                Exclude(~Seq27,x);
            elif x in Seq24 then
                Exclude(~Seq27,x);
            elif x in Seq25 then
                Exclude(~Seq27,x);
            elif x in Seq26 then
                Exclude(~Seq27,x);
            end if;
        end for;
        for x in Seq28 do
            if x in Seq21 then
                Exclude(~Seq28,x);
            elif x in Seq22 then
                Exclude(~Seq28,x);
            elif x in Seq23 then
                Exclude(~Seq28,x);
            elif x in Seq24 then
                Exclude(~Seq28,x);
            elif x in Seq25 then
                Exclude(~Seq28,x);
            elif x in Seq26 then
                Exclude(~Seq28,x);
            end if;
        end for;


        sum[j] :=  [#Seq21+#Seq22+#Seq23+#Seq24+#Seq25+#Seq26+#Seq27+#Seq28,p];

    elif D eq Matrix(Rationals(),6,[1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,0,0,0, 0,0,0,-1,0,0, 0,0,0,0,-1,0, 0,0,0,0,0,-1]) then

        Seq01 := {{[1,y1,z1,r1,s1,t1],[1,y1,z1,-r1,-s1,-t1]}: y1,z1,r1,s1,t1 in GF(p)|(Evaluate(f,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<1,y1,z1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<1,y1,z1,-r1,-s1,-t1>) eq 0)};
        Seq01:=IndexedSet(Seq01);
        Seq11 := {};
        Seq11 := SetToIndexedSet(Seq11);
        for i in [1..#Seq01] do
            conversion:=SetToIndexedSet(Seq01[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq11,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq11,{p1,p2});
            end if;
        end for; 

        Seq02 := {{[0,1,z1,r1,s1,t1],[0,1,z1,-r1,-s1,-t1]}: z1,r1,s1,t1 in GF(p)|(Evaluate(f,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,1,z1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,1,z1,-r1,-s1,-t1>) eq 0)};
        Seq02:=IndexedSet(Seq02);
        Seq12 := {};
        Seq12 := SetToIndexedSet(Seq12);
        for i in [1..#Seq02] do
            conversion:=SetToIndexedSet(Seq02[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq12,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq12,{p1,p2});
            end if;
        end for; 

        Seq03 := {{[0,0,1,r1,s1,t1],[0,0,1,-r1,-s1,-t1]}: r1,s1,t1 in GF(p)|(Evaluate(f,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,0,1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,0,1,-r1,-s1,-t1>) eq 0)};
        Seq03:=IndexedSet(Seq03);
        Seq13 := {};
        Seq13 := SetToIndexedSet(Seq13);
        for i in [1..#Seq03] do
            conversion:=SetToIndexedSet(Seq03[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq13,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq13,{p1,p2});
            end if;
        end for; 

        Seq04 := {{[0,0,0,1,s1,t1],[0,0,0,-1,-s1,-t1]}: s1,t1 in GF(p)|(Evaluate(f,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(f,<0,0,0,-1,-s1,-t1>) eq 0) and (Evaluate(h,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(h,<0,0,0,-1,-s1,-t1>) eq 0)};
        Seq04:=IndexedSet(Seq04);
        Seq14 := {};
        Seq14 := SetToIndexedSet(Seq14);
        for i in [1..#Seq04] do
            conversion:=SetToIndexedSet(Seq04[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq14,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq14,{p1,p2});
            end if;
        end for; 

        Seq05 := {{[0,0,0,0,1,t1],[0,0,0,0,-1,-t1]}: t1 in GF(p)|(Evaluate(f,<0,0,0,0,1,t1>) eq 0) and (Evaluate(f,<0,0,0,0,-1,-t1>) eq 0) and (Evaluate(h,<0,0,0,0,1,t1>) eq 0) and (Evaluate(h,<0,0,0,0,-1,-t1>) eq 0)};
        Seq05:=IndexedSet(Seq05);
        Seq15 := {};
        Seq15 := SetToIndexedSet(Seq15);
        for i in [1..#Seq05] do
            conversion:=SetToIndexedSet(Seq05[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq15,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq15,{p1,p2});
            end if;
        end for; 

        if (Evaluate(f,<0,0,0,0,0,1>) eq 0) and (Evaluate(f,<0,0,0,0,0,-1>) eq 0) and (Evaluate(h,<0,0,0,0,0,1>) eq 0) and (Evaluate(h,<0,0,0,0,0,-1>) eq 0) then
            Seq06 := {[0,0,0,0,0,1]};
            Seq06 := SetToIndexedSet(Seq06);
            Seq16 := {};
            Seq16 := SetToIndexedSet(Seq16);
            bool1,p1 := Seq06[1] in Proj;
            Include(~Seq16,{p1});
        else
            Seq16 := SetToIndexedSet({});
        end if;
 
        SquareRoots := {SquareRoot(w1) : w1 in GF(p^2)|w1 ne 0 and w1 in GF(p) and IsSquare(w1) eq true and SquareRoot(w1) notin GF(p)};
        sqrt := Representative(SquareRoots);
        times_SquareRoots := {a*sqrt : a in GF(p)};

        Seq07 := {{[x1,y1,z1,1,s1,t1],[-x1,-y1,-z1,1,s1,t1]}: x1,y1,z1 in times_SquareRoots, s1,t1 in GF(p)|(x1 notin GF(p) or y1 notin GF(p) or z1 notin GF(p)) and (Evaluate(f,<x1,y1,z1,1,s1,t1>) eq 0) and (Evaluate(f,<-x1,-y1,-z1,1,s1,t1>) eq 0) and (Evaluate(h,<x1,y1,z1,1,s1,t1>) eq 0) and (Evaluate(h,<-x1,-y1,-z1,1,s1,t1>) eq 0)};
        Seq07:=IndexedSet(Seq07);
        Seq17 := {};
        Seq17 := SetToIndexedSet(Seq17);
        for i in [1..#Seq07] do
            conversion:=SetToIndexedSet(Seq07[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq17,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq17,{p1,p2});
            end if;
        end for; 

        Seq08 := {{[x1,y1,z1,0,1,t1],[-x1,-y1,-z1,0,1,t1]}: x1,y1,z1 in times_SquareRoots, t1 in GF(p)|(x1 notin GF(p) or y1 notin GF(p) or z1 notin GF(p)) and (Evaluate(f,<x1,y1,z1,0,1,t1>) eq 0) and (Evaluate(f,<-x1,-y1,-z1,0,1,t1>) eq 0) and (Evaluate(h,<x1,y1,z1,0,1,t1>) eq 0) and (Evaluate(h,<-x1,-y1,-z1,0,1,t1>) eq 0)};
        Seq08:=IndexedSet(Seq08);
        Seq18 := {};
        Seq18 := SetToIndexedSet(Seq18);
        for i in [1..#Seq08] do
            conversion:=SetToIndexedSet(Seq08[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq18,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq18,{p1,p2});
            end if;
        end for; 

        Seq09 := {{[x1,y1,z1,0,0,1],[-x1,-y1,-z1,0,0,1]}: x1,y1,z1 in times_SquareRoots|(x1 notin GF(p) or y1 notin GF(p) or z1 notin GF(p)) and (Evaluate(f,<x1,y1,z1,0,0,1>) eq 0) and (Evaluate(f,<-x1,-y1,-z1,0,0,1>) eq 0) and (Evaluate(h,<x1,y1,z1,0,0,1>) eq 0) and (Evaluate(h,<-x1,-y1,-z1,0,0,1>) eq 0)};
        Seq09:=IndexedSet(Seq09);
        Seq19 := {};
        Seq19 := SetToIndexedSet(Seq19);
        for i in [1..#Seq09] do
            conversion:=SetToIndexedSet(Seq09[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq19,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq19,{p1,p2});
            end if;
        end for; 

        Seq21 := IndexedSetToSet(Seq11);
        Seq22 := IndexedSetToSet(Seq12);
        Seq23 := IndexedSetToSet(Seq13);
        Seq24 := IndexedSetToSet(Seq14);
        Seq25 := IndexedSetToSet(Seq15);
        Seq26 := IndexedSetToSet(Seq16);
        Seq27 := IndexedSetToSet(Seq17);
        Seq28 := IndexedSetToSet(Seq18);
        Seq29 := IndexedSetToSet(Seq19);


        /*Check for repeated points*/
        for x in Seq27 do
            if x in Seq21 then
                Exclude(~Seq27,x);
            elif x in Seq22 then
                Exclude(~Seq27,x);
            elif x in Seq23 then
                Exclude(~Seq27,x);
            elif x in Seq24 then
                Exclude(~Seq27,x);
            elif x in Seq25 then
                Exclude(~Seq27,x);
            elif x in Seq26 then
                Exclude(~Seq27,x);
            end if;
        end for;
        for x in Seq28 do
            if x in Seq21 then
                Exclude(~Seq28,x);
            elif x in Seq22 then
                Exclude(~Seq28,x);
            elif x in Seq23 then
                Exclude(~Seq28,x);
            elif x in Seq24 then
                Exclude(~Seq28,x);
            elif x in Seq25 then
                Exclude(~Seq28,x);
            elif x in Seq26 then
                Exclude(~Seq28,x);
            end if;
        end for;
        for x in Seq29 do
            if x in Seq21 then
                Exclude(~Seq29,x);
            elif x in Seq22 then
                Exclude(~Seq29,x);
            elif x in Seq23 then
                Exclude(~Seq29,x);
            elif x in Seq24 then
                Exclude(~Seq29,x);
            elif x in Seq25 then
                Exclude(~Seq29,x);
            elif x in Seq26 then
                Exclude(~Seq29,x);
            end if;
        end for;

        sum[j] :=  [#Seq21+#Seq22+#Seq23+#Seq24+#Seq25+#Seq26+#Seq27+#Seq28+#Seq29,p];

    elif D eq Matrix(Rationals(),6,[1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,-1,0,0,0, 0,0,0,-1,0,0, 0,0,0,0,-1,0, 0,0,0,0,0,-1]) then
  
        Seq01 := {{[1,y1,z1,r1,s1,t1],[1,y1,-z1,-r1,-s1,-t1]}: y1,z1,r1,s1,t1 in GF(p)|(Evaluate(f,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<1,y1,-z1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<1,y1,-z1,-r1,-s1,-t1>) eq 0)};
        Seq01:=IndexedSet(Seq01);
        Seq11 := {};
        Seq11 := SetToIndexedSet(Seq11);
        for i in [1..#Seq01] do
            conversion:=SetToIndexedSet(Seq01[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq11,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq11,{p1,p2});
            end if;
        end for; 

        Seq02 := {{[0,1,z1,r1,s1,t1],[0,1,-z1,-r1,-s1,-t1]}: z1,r1,s1,t1 in GF(p)|(Evaluate(f,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,1,-z1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,1,-z1,-r1,-s1,-t1>) eq 0)};
        Seq02:=IndexedSet(Seq02);
        Seq12 := {};
        Seq12 := SetToIndexedSet(Seq12);
        for i in [1..#Seq02] do
            conversion:=SetToIndexedSet(Seq02[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq12,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq12,{p1,p2});
            end if;
        end for; 

        Seq03 := {{[0,0,1,r1,s1,t1],[0,0,-1,-r1,-s1,-t1]}: r1,s1,t1 in GF(p)|(Evaluate(f,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,0,-1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,0,1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,0,-1,-r1,-s1,-t1>) eq 0)};
        Seq03:=IndexedSet(Seq03);
        Seq13 := {};
        Seq13 := SetToIndexedSet(Seq13);
        for i in [1..#Seq03] do
            conversion:=SetToIndexedSet(Seq03[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq13,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq13,{p1,p2});
            end if;
        end for; 

        Seq04 := {{[0,0,0,1,s1,t1],[0,0,0,-1,-s1,-t1]}: s1,t1 in GF(p)|(Evaluate(f,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(f,<0,0,0,-1,-s1,-t1>) eq 0) and (Evaluate(h,<0,0,0,1,s1,t1>) eq 0) and (Evaluate(h,<0,0,0,-1,-s1,-t1>) eq 0)};
        Seq04:=IndexedSet(Seq04);
        Seq14 := {};
        Seq14 := SetToIndexedSet(Seq14);
        for i in [1..#Seq04] do
            conversion:=SetToIndexedSet(Seq04[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq14,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq14,{p1,p2});
            end if;
        end for; 

        Seq05 := {{[0,0,0,0,1,t1],[0,0,0,0,-1,-t1]}: t1 in GF(p)|(Evaluate(f,<0,0,0,0,1,t1>) eq 0) and (Evaluate(f,<0,0,0,0,-1,-t1>) eq 0) and (Evaluate(h,<0,0,0,0,1,t1>) eq 0) and (Evaluate(h,<0,0,0,0,-1,-t1>) eq 0)};
        Seq05:=IndexedSet(Seq05);
        Seq15 := {};
        Seq15 := SetToIndexedSet(Seq15);
        for i in [1..#Seq05] do
            conversion:=SetToIndexedSet(Seq05[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq15,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq15,{p1,p2});
            end if;
        end for; 

        if (Evaluate(f,<0,0,0,0,0,1>) eq 0) and (Evaluate(f,<0,0,0,0,0,-1>) eq 0) and (Evaluate(h,<0,0,0,0,0,1>) eq 0) and (Evaluate(h,<0,0,0,0,0,-1>) eq 0) then
            Seq06 := {[0,0,0,0,0,1]};
            Seq06 := SetToIndexedSet(Seq06);
            Seq16 := {};
            Seq16 := SetToIndexedSet(Seq16);
            bool1,p1 := Seq06[1] in Proj;
            Include(~Seq16,{p1});
        else
            Seq16 := SetToIndexedSet({});
        end if;
    
        SquareRoots := {SquareRoot(w1) : w1 in GF(p^2)|w1 ne 0 and w1 in GF(p) and IsSquare(w1) eq true and SquareRoot(w1) notin GF(p)};
        sqrt := Representative(SquareRoots);
        times_SquareRoots := {a*sqrt : a in GF(p)};

        Seq07 := {{[1,y1,z1,r1,s1,t1],[1,y1,-z1,-r1,-s1,-t1]}: z1,r1,s1,t1 in times_SquareRoots, y1 in GF(p)|(z1 notin GF(p) or r1 notin GF(p) or s1 notin GF(p) or t1 notin GF(p)) and (Evaluate(f,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<1,y1,-z1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<1,y1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<1,y1,-z1,-r1,-s1,-t1>) eq 0)};
        Seq07:=IndexedSet(Seq07);
        Seq17 := {};
        Seq17 := SetToIndexedSet(Seq17);
        for i in [1..#Seq07] do
            conversion:=SetToIndexedSet(Seq07[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq17,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq17,{p1,p2});
            end if;
        end for; 

        Seq08 := {{[0,1,z1,r1,s1,t1],[0,1,-z1,-r1,-s1,-t1]}: z1,r1,s1,t1 in times_SquareRoots|(z1 notin GF(p) or r1 notin GF(p) or s1 notin GF(p) or t1 notin GF(p)) and (Evaluate(f,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(f,<0,1,-z1,-r1,-s1,-t1>) eq 0) and (Evaluate(h,<0,1,z1,r1,s1,t1>) eq 0) and (Evaluate(h,<0,1,-z1,-r1,-s1,-t1>) eq 0)};
        Seq08:=IndexedSet(Seq08);
        Seq18 := {};
        Seq18 := SetToIndexedSet(Seq18);
        for i in [1..#Seq08] do
            conversion:=SetToIndexedSet(Seq08[i]);
            if #conversion eq 1 then
                bool1,p1 := conversion[1] in Proj;
                Include(~Seq18,{p1});
            elif #conversion eq 2 then
                bool1,p1 := conversion[1] in Proj;
                bool2,p2 := conversion[2] in Proj;
                Include(~Seq18,{p1,p2});
            end if;
        end for; 

        Seq21 := IndexedSetToSet(Seq11);
        Seq22 := IndexedSetToSet(Seq12);
        Seq23 := IndexedSetToSet(Seq13);
        Seq24 := IndexedSetToSet(Seq14);
        Seq25 := IndexedSetToSet(Seq15);
        Seq26 := IndexedSetToSet(Seq16);
        Seq27 := IndexedSetToSet(Seq17);
        Seq28 := IndexedSetToSet(Seq18);


        /*Check for repeated points*/
        for x in Seq27 do
            if x in Seq21 then
                Exclude(~Seq27,x);
            elif x in Seq22 then
                Exclude(~Seq27,x);
            elif x in Seq23 then
                Exclude(~Seq27,x);
            elif x in Seq24 then
                Exclude(~Seq27,x);
            elif x in Seq25 then
                Exclude(~Seq27,x);
            elif x in Seq26 then
                Exclude(~Seq27,x);
            end if;
        end for;
        for x in Seq28 do
            if x in Seq21 then
                Exclude(~Seq28,x);
            elif x in Seq22 then
                Exclude(~Seq28,x);
            elif x in Seq23 then
                Exclude(~Seq28,x);
            elif x in Seq24 then
                Exclude(~Seq28,x);
            elif x in Seq25 then
                Exclude(~Seq28,x);
            elif x in Seq26 then
                Exclude(~Seq28,x);
            end if;
        end for;

        sum[j] :=  [#Seq21+#Seq22+#Seq23+#Seq24+#Seq25+#Seq26+#Seq27+#Seq28,p];
    
    end if;


end for;


return(sum);


end function;


/*
Inputs: sum - vector of pairs [s,p], where s and p are integers.
Outputs: sum - vector of pairs [s,p], where s and p are integers.
Function: GoodPrimes - this function takes in a vector consisting of pairs of 
integers, sum, and removes all pairs in sum whose first coordinate is 0. It
then outputs the result.
*/

GoodPrimes := function(sum)
    

    for x in sum do
        if x[1] eq 0 then
		Exclude(~sum,x);
        end if;
    end for;

    return(sum);
end function;



/*
Inputs: good_sum - vector of pairs [s,p], where s and p are integers.
        search_min - positive integer.
        search_max - positive integer.
Outputs: weight_4_level - vector triple [x,y,z], where x,y,z are integers.
Function: FindWeight4Form - this function takes as input good_sum, a vector 
of pairs of integers, [s,p]. For each weight 4 newform of levels between 
search_min to search_max, the function compares the p-th coefficient of the 
newform to the integer s corresponding to p in a pair [s,p] for each pair in 
good_sum, and stops if all pairs agree with the coefficients. It either returns
[0,0,0] if no weight 4 newforms check out in the search, or [x,y,z], where 
ModularForms(Gamma0(x),4)[y,z] is the newform corresponding to good_sum.
*/

FindWeight4Form := function(good_sum,search_min,search_max)

X:=[0 : i in [1..#good_sum]];
weight_4_level := [0,0,0];
weight_4_coeff := [[0,good_sum[i][2]] : i in [1..#good_sum]];
for C in [search_min..search_max] do
    M:=ModularForms(Gamma0(C),4);
    N:=NumberOfNewformClasses(M);
        if (N gt 0) then
                    for i in [1..N] do
                        L:=#Newforms(M)[i];
                            for k in [1..L] do
                                for j in [1..#good_sum] do
				    p := good_sum[j][2];
                                    if( IsCoercible(Integers(),Coefficient(Newform(M,i,k),p)) ) then 
                                        bool,x:=IsCoercible(Integers(),Coefficient(Newform(M,i,k),p));
                                            if (((1-x) mod p) eq (good_sum[j][1] mod p)) then
                                                weight_4_coeff[j] := [x,p];
                                                X[j] := 1;
                                            end if;
                                    end if;
                               end for;
                            if X eq [1 : i in [1..#good_sum]] then   
				ii := i; kk := k;
                                break;
                            else
                                weight_4_coeff := [[0,good_sum[i][2]] : i in [1..#good_sum]];
                                X := [0 : i in [1..#good_sum]];;
                            end if;
                        end for;
                    if X eq [1 : i in [1..#good_sum]] then
                       break;
                    end if;    
                  end for;
              if X eq [1 : i in [1..#good_sum]] then
                    weight_4_level := [C,ii,kk];
                    break;
              else
                    weight_4_coeff := [[0,good_sum[i][2]] : i in [1..#good_sum]];
                    X := [0 : i in [1..#good_sum]];
              end if;
        end if;
end for;

return(weight_4_level);


end function;




/*
Inputs: counts - vector of pairs [s,p], where s and p are integers.
        weight4level - a triple of integers [x,y,z], where 
                        ModularForms(Gamma0(x),4)[y,z] is a weight 4 newform.
Outputs: s - vector of real numbers.
Function: FirstCoefficient - this functions approximates the first coefficient
for each pair in counts, and stores each approximation as a coordinate in s. It 
returns s.
*/


FirstCoefficient := function(counts,weight4level)

    nf := Newforms(CuspForms(weight4level[1],4))[weight4level[2],weight4level[3]];
    Z := Integers();
    s := [<Z!((x[1]+Coefficient(nf,x[2])-x[2]^3-1)/x[2]),x[2]> : x in counts];
    
    return(s);

end function;



/*
Inputs: counts - vector of pairs [s,p], where s and p are integers.
        weight4level - a triple of integers [x,y,z], where 
                        ModularForms(Gamma0(x),4)[y,z] is a weight 4 newform.
        first_coeff - integer.
Outputs: <C,A> - vector, where C=[c1,c2,c3,c4,c5,c6] is the zero vector
or the vector of coefficients in 
[<c1+c2*LegendreSymbol(-1,x[2])+c3*LegendreSymbol(2,x[2])+c4*LegendreSymbol(-2,x[2])+c5*LegendreSymbol(3,x[2])+c6*LegendreSymbol(-3,x[2]),x[2]>],
and A is a set of vectors of pairs <s,p>, where s and p are integers.
Function: SecondCoefficient - this functions attempts to determine whether the 
sets A (defined in the function) and C (also defined in the function) coincide.
If not, C is the zero vector. It returns <C,A>.
*/

SecondCoefficient := function(counts,weight4level,first_coeff)

    nf := Newforms(CuspForms(weight4level[1],4))[weight4level[2],weight4level[3]];
    Z := Integers();
    A := [<(x[1]+Coefficient(nf,x[2])-x[2]^3-first_coeff*(x[2]^2)-1)/x[2],x[2]> : x in counts | x[2] ne 3];
    X :=0;
    C := [0,0,0,0,0,0];
    for a,b,c,d,e,f in [-3..3] do
        X := [<a+b*LegendreSymbol(-1,x[2])+c*LegendreSymbol(2,x[2])+d*LegendreSymbol(-2,x[2])+e*LegendreSymbol(3,x[2])+f*LegendreSymbol(-3,x[2]),x[2]> : x in counts | x[2] ne 3];
        if X eq A then
            X := [<a+b*LegendreSymbol(-1,x[2])+c*LegendreSymbol(2,x[2])+d*LegendreSymbol(-2,x[2])+e*LegendreSymbol(3,x[2])+f*LegendreSymbol(-3,x[2]),x[2]> : x in counts | x[2] ne 3];
            C := [a,b,c,d,e,f];
            break;
        end if;
    end for;
    
    return(<C,A>);

end function;














/*MAIN*/
/*****************************************************************************/
/*Required input*/

/*Polynomial ring, P:*/
P<x,y,z,r,s,t> := PolynomialRing(Rationals(),6);
/*Complete intersection of*/
a1 := 1;
a2 := 1;
a3 := 1;
a4 := 1;
a5 := 1;
a6 := 1;
Q<x,y,z,r,s,t>:=x+y+z+t+r+s;
R<x,y,z,r,s,t>:=a1*y*z*t*r*s+a2*x*z*t*r*s+a3*x*y*t*r*s+a4*x*y*z*r*s+a5*x*y*z*t*s+a6*x*y*z*t*r;
/*Transformation matrix, T:*/
for T in TranslationIntersection(Q,R) do
    /*prime range, min_prime and max_prime:*/
    min_prime := 1;
    max_prime := 6;
    /*newform level range, min_weight4 and max_weight4:*/
    min_weight4 :=6;
    max_weight4 :=6;
    print "Transformation matrix is:", T;
    "";
    Diag := Diagonalization(T);
    print "Diagonal matrix is:", Diag[1];
    "";
    if Determinant(Diag[1]) eq 1 then
        CoC := ChangeOfCoordinates(Q,R,T);
        sum := CountPoints(CoC[1],CoC[2],Diag[1],min_prime,max_prime);
        print "Point counts are", sum;
        "";
        good_sum := GoodPrimes(sum);
        print "Good point counts are", good_sum;
        "";
        weight4level := FindWeight4Form(good_sum,min_weight4,max_weight4);
        print "Level of weight 4 newform is", weight4level;
        "";
        if weight4level ne [0,0,0] then
        	first_coeff := FirstCoefficient(good_sum,weight4level);
	        print "First coefficient can be obtained from: ", first_coeff;
	        second := SecondCoefficient(good_sum,weight4level,1);
                print "Second coefficient is ", second;
        else
                print "not modular";
        end if;
    end if;
    print "";
    print "";
    print "---------------------------------------------------------";
    print "";
    print "";
end for;

